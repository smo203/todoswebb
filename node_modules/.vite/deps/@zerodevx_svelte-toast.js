import "./chunk-ZG4BI7MI.js";
import {
  flip
} from "./chunk-W77EZ2U3.js";
import {
  tweened
} from "./chunk-LC6HCP2Z.js";
import {
  writable
} from "./chunk-ELWQYM4I.js";
import {
  fade,
  fly
} from "./chunk-WLLSPT57.js";
import "./chunk-VFRMSNTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  add_render_callback,
  add_transform,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  component_subscribe,
  construct_svelte_component_dev,
  create_animation,
  create_component,
  create_in_transition,
  create_out_transition,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  fix_and_outro_and_destroy_block,
  fix_position,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  identity,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  space,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-DASXCH3S.js";
import "./chunk-JI7YFEPT.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@zerodevx/svelte-toast/stores.js
var defaults = {
  duration: 4e3,
  initial: 1,
  next: 0,
  pausable: false,
  dismissable: true,
  reversed: false,
  intro: { x: 256 }
};
function createToast() {
  const { subscribe, update } = writable(new Array());
  const options = {};
  let count = 0;
  function _obj(obj) {
    return obj instanceof Object;
  }
  function _init(target = "default", opts = {}) {
    options[target] = opts;
    return options;
  }
  function push(msg, opts) {
    const param = {
      target: "default",
      ..._obj(msg) ? (
        /** @type {SvelteToastOptions} */
        msg
      ) : { ...opts, msg }
    };
    const conf = options[param.target] || {};
    const entry = {
      ...defaults,
      ...conf,
      ...param,
      theme: { ...conf.theme, ...param.theme },
      classes: [...conf.classes || [], ...param.classes || []],
      id: ++count
    };
    update((n) => entry.reversed ? [...n, entry] : [entry, ...n]);
    return count;
  }
  function pop(id) {
    update((n) => {
      if (!n.length || id === 0)
        return [];
      if (typeof id === "function")
        return n.filter((i) => id(i));
      if (_obj(id))
        return n.filter(
          /** @type {SvelteToastOptions[]} i */
          (i) => i.target !== id.target
        );
      const found = id || Math.max(...n.map((i) => i.id));
      return n.filter((i) => i.id !== found);
    });
  }
  function set(id, opts) {
    const param = _obj(id) ? id : { ...opts, id };
    update((n) => {
      const idx = n.findIndex((i) => i.id === param.id);
      if (idx > -1) {
        n[idx] = { ...n[idx], ...param };
      }
      return n;
    });
  }
  return { subscribe, push, pop, set, _init };
}
var toast = createToast();

// node_modules/@zerodevx/svelte-toast/ToastItem.svelte
var file = "node_modules/@zerodevx/svelte-toast/ToastItem.svelte";
function add_css(target) {
  append_styles(target, "svelte-95rq8t", "._toastItem.svelte-95rq8t{width:var(--toastWidth, 16rem);height:var(--toastHeight, auto);min-height:var(--toastMinHeight, 3.5rem);margin:var(--toastMargin, 0 0 0.5rem 0);padding:var(--toastPadding, 0);background:var(--toastBackground, rgba(66, 66, 66, 0.9));color:var(--toastColor, #fff);box-shadow:var(\n    --toastBoxShadow,\n    0 4px 6px -1px rgba(0, 0, 0, 0.1),\n    0 2px 4px -1px rgba(0, 0, 0, 0.06)\n  );border:var(--toastBorder, none);border-radius:var(--toastBorderRadius, 0.125rem);position:relative;display:flex;flex-direction:row;align-items:center;overflow:hidden;will-change:transform, opacity;-webkit-tap-highlight-color:transparent}._toastMsg.svelte-95rq8t{padding:var(--toastMsgPadding, 0.75rem 0.5rem);flex:1 1 0%}.pe.svelte-95rq8t,._toastMsg.svelte-95rq8t a{pointer-events:auto}._toastBtn.svelte-95rq8t{width:var(--toastBtnWidth, 2rem);height:var(--toastBtnHeight, 100%);cursor:pointer;outline:none}._toastBtn.svelte-95rq8t::after{content:var(--toastBtnContent, 'âœ•');font:var(--toastBtnFont, 1rem sans-serif);display:flex;align-items:center;justify-content:center}._toastBar.svelte-95rq8t{top:var(--toastBarTop, auto);right:var(--toastBarRight, auto);bottom:var(--toastBarBottom, 0);left:var(--toastBarLeft, 0);height:var(--toastBarHeight, 6px);width:var(--toastBarWidth, 100%);position:absolute;display:block;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;background:transparent;pointer-events:none}._toastBar.svelte-95rq8t::-webkit-progress-bar{background:transparent}._toastBar.svelte-95rq8t::-webkit-progress-value{background:var(--toastProgressBackground, var(--toastBarBackground, rgba(33, 150, 243, 0.75)))}._toastBar.svelte-95rq8t::-moz-progress-bar{background:var(--toastProgressBackground, var(--toastBarBackground, rgba(33, 150, 243, 0.75)))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function create_else_block(ctx) {
  let html_tag;
  let raw_value = (
    /*item*/
    ctx[0].msg + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*item*/
      1 && raw_value !== (raw_value = /*item*/
      ctx2[0].msg + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(98:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*cprops*/
    ctx[2]
  ];
  var switch_value = (
    /*item*/
    ctx[0].component.src
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*cprops*/
    4) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*cprops*/
        ctx2[2]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*item*/
      1 && switch_value !== (switch_value = /*item*/
      ctx2[0].component.src)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*cprops*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*cprops*/
          ctx2[2]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(96:4) {#if item.component}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true, tabindex: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "_toastBtn pe svelte-95rq8t");
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "0");
      add_location(div, file, 102, 4, 2271);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*close*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(102:2) {#if item.dismissable}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let progress_1;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*item*/
      ctx2[0].component
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*item*/
    ctx[0].dismissable && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      progress_1 = element("progress");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { role: true, class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      progress_1 = claim_element(div1_nodes, "PROGRESS", { class: true });
      children(progress_1).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "_toastMsg svelte-95rq8t");
      toggle_class(
        div0,
        "pe",
        /*item*/
        ctx[0].component
      );
      add_location(div0, file, 94, 2, 2048);
      attr_dev(progress_1, "class", "_toastBar svelte-95rq8t");
      progress_1.value = /*$progress*/
      ctx[1];
      add_location(progress_1, file, 112, 2, 2500);
      attr_dev(div1, "role", "status");
      attr_dev(div1, "class", "_toastItem svelte-95rq8t");
      toggle_class(
        div1,
        "pe",
        /*item*/
        ctx[0].pausable
      );
      add_location(div1, file, 85, 0, 1889);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append_hydration_dev(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, progress_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            /*resume*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      if (!current || dirty & /*item*/
      1) {
        toggle_class(
          div0,
          "pe",
          /*item*/
          ctx2[0].component
        );
      }
      if (
        /*item*/
        ctx2[0].dismissable
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*$progress*/
      2) {
        prop_dev(
          progress_1,
          "value",
          /*$progress*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*item*/
      1) {
        toggle_class(
          div1,
          "pe",
          /*item*/
          ctx2[0].pausable
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function check(prop, kind = "undefined") {
  return typeof prop === kind;
}
function instance($$self, $$props, $$invalidate) {
  let $progress;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastItem", slots, []);
  let { item } = $$props;
  let next = item.initial;
  let prev = next;
  let paused = false;
  let cprops = {};
  let unlisten;
  const progress = tweened(item.initial, { duration: item.duration, easing: identity });
  validate_store(progress, "progress");
  component_subscribe($$self, progress, (value) => $$invalidate(1, $progress = value));
  function close() {
    toast.pop(item.id);
  }
  function autoclose() {
    if ($progress === 1 || $progress === 0)
      close();
  }
  function pause() {
    if (!paused && $progress !== next) {
      progress.set($progress, { duration: 0 });
      paused = true;
    }
  }
  function resume() {
    if (paused) {
      const d = (
        /** @type {any} */
        item.duration
      );
      const duration = d - d * (($progress - prev) / (next - prev));
      progress.set(next, { duration }).then(autoclose);
      paused = false;
    }
  }
  function listen(d = document) {
    if (check(d.hidden))
      return;
    const handler = () => d.hidden ? pause() : resume();
    const name = "visibilitychange";
    d.addEventListener(name, handler);
    unlisten = () => d.removeEventListener(name, handler);
    handler();
  }
  onMount(listen);
  onDestroy(() => {
    if (check(item.onpop, "function")) {
      item.onpop(item.id);
    }
    unlisten && unlisten();
  });
  $$self.$$.on_mount.push(function() {
    if (item === void 0 && !("item" in $$props || $$self.$$.bound[$$self.$$.props["item"]])) {
      console.warn("<ToastItem> was created without expected prop 'item'");
    }
  });
  const writable_props = ["item"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToastItem> was created with unknown prop '${key}'`);
  });
  const keydown_handler = (e) => {
    if (e instanceof KeyboardEvent && ["Enter", " "].includes(e.key))
      close();
  };
  const mouseenter_handler = () => {
    if (item.pausable)
      pause();
  };
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    tweened,
    linear: identity,
    toast,
    item,
    next,
    prev,
    paused,
    cprops,
    unlisten,
    progress,
    close,
    autoclose,
    pause,
    resume,
    check,
    listen,
    $progress
  });
  $$self.$inject_state = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("next" in $$props2)
      $$invalidate(7, next = $$props2.next);
    if ("prev" in $$props2)
      prev = $$props2.prev;
    if ("paused" in $$props2)
      paused = $$props2.paused;
    if ("cprops" in $$props2)
      $$invalidate(2, cprops = $$props2.cprops);
    if ("unlisten" in $$props2)
      unlisten = $$props2.unlisten;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $:
        if (!check(item.progress)) {
          $$invalidate(0, item.next = item.progress, item);
        }
    }
    if ($$self.$$.dirty & /*next, item, $progress*/
    131) {
      $:
        if (next !== item.next) {
          $$invalidate(7, next = item.next);
          prev = $progress;
          paused = false;
          progress.set(next).then(autoclose);
        }
    }
    if ($$self.$$.dirty & /*item*/
    1) {
      $:
        if (item.component) {
          const { props = {}, sendIdTo } = item.component;
          $$invalidate(2, cprops = {
            ...props,
            ...sendIdTo && { [sendIdTo]: item.id }
          });
        }
    }
  };
  return [
    item,
    $progress,
    cprops,
    progress,
    close,
    pause,
    resume,
    next,
    keydown_handler,
    mouseenter_handler
  ];
}
var ToastItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { item: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastItem",
      options,
      id: create_fragment.name
    });
  }
  get item() {
    throw new Error("<ToastItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<ToastItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastItem_default = ToastItem;

// node_modules/@zerodevx/svelte-toast/SvelteToast.svelte
var { Object: Object_1 } = globals;
var file2 = "node_modules/@zerodevx/svelte-toast/SvelteToast.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1u812xz", "._toastContainer.svelte-1u812xz{top:var(--toastContainerTop, 1.5rem);right:var(--toastContainerRight, 2rem);bottom:var(--toastContainerBottom, auto);left:var(--toastContainerLeft, auto);position:fixed;margin:0;padding:0;list-style-type:none;pointer-events:none;z-index:var(--toastContainerZIndex, 9999)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHRlVG9hc3Quc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVDQSwrQkFBaUIsQ0FDZixHQUFHLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FDckMsS0FBSyxDQUFFLElBQUkscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQ3ZDLE1BQU0sQ0FBRSxJQUFJLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUN6QyxJQUFJLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FDckMsUUFBUSxDQUFFLEtBQUssQ0FDZixNQUFNLENBQUUsQ0FBQyxDQUNULE9BQU8sQ0FBRSxDQUFDLENBQ1YsZUFBZSxDQUFFLElBQUksQ0FDckIsY0FBYyxDQUFFLElBQUksQ0FDcEIsT0FBTyxDQUFFLElBQUksc0JBQXNCLENBQUMsS0FBSyxDQUMzQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTdmVsdGVUb2FzdC5zdmVsdGUiXX0= */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let li;
  let toastitem;
  let t;
  let li_class_value;
  let li_style_value;
  let li_intro;
  let li_outro;
  let rect;
  let stop_animation = noop;
  let current;
  toastitem = new ToastItem_default({
    props: { item: (
      /*item*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      li = element("li");
      create_component(toastitem.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true, style: true });
      var li_nodes = children(li);
      claim_component(toastitem.$$.fragment, li_nodes);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(li, "class", li_class_value = null_to_empty(
        /*item*/
        (_a = ctx[4].classes) == null ? void 0 : _a.join(" ")
      ) + " svelte-1u812xz");
      attr_dev(li, "style", li_style_value = getCss(
        /*item*/
        ctx[4].theme
      ));
      add_location(li, file2, 26, 4, 731);
      this.first = li;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      mount_component(toastitem, li, null);
      append_hydration_dev(li, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      const toastitem_changes = {};
      if (dirty & /*items*/
      1)
        toastitem_changes.item = /*item*/
        ctx[4];
      toastitem.$set(toastitem_changes);
      if (!current || dirty & /*items*/
      1 && li_class_value !== (li_class_value = null_to_empty(
        /*item*/
        (_a = ctx[4].classes) == null ? void 0 : _a.join(" ")
      ) + " svelte-1u812xz")) {
        attr_dev(li, "class", li_class_value);
      }
      if (!current || dirty & /*items*/
      1 && li_style_value !== (li_style_value = getCss(
        /*item*/
        ctx[4].theme
      ))) {
        attr_dev(li, "style", li_style_value);
      }
    },
    r: function measure() {
      rect = li.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(li);
      stop_animation();
      add_transform(li, rect);
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(li, rect, flip, { duration: 200 });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastitem.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (li_outro)
            li_outro.end(1);
          li_intro = create_in_transition(
            li,
            fly,
            /*item*/
            ctx[4].intro
          );
          li_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(toastitem.$$.fragment, local);
      if (li_intro)
        li_intro.invalidate();
      if (local) {
        li_outro = create_out_transition(li, fade, {});
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      destroy_component(toastitem);
      if (detaching && li_outro)
        li_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(26:2) {#each items as item (item.id)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[4].id
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "_toastContainer svelte-1u812xz");
      add_location(ul, file2, 24, 0, 664);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*items, getCss*/
      1) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[0]
        );
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getCss(theme) {
  return theme ? Object.keys(theme).reduce((a, c) => `${a}${c}:${theme[c]};`, "") : void 0;
}
function instance2($$self, $$props, $$invalidate) {
  let $toast;
  validate_store(toast, "toast");
  component_subscribe($$self, toast, ($$value) => $$invalidate(3, $toast = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteToast", slots, []);
  let { options = {} } = $$props;
  let { target = "default" } = $$props;
  let items = [];
  const writable_props = ["options", "target"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SvelteToast> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
  };
  $$self.$capture_state = () => ({
    fade,
    fly,
    flip,
    toast,
    ToastItem: ToastItem_default,
    options,
    target,
    items,
    getCss,
    $toast
  });
  $$self.$inject_state = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*target, options*/
    6) {
      $:
        toast._init(target, options);
    }
    if ($$self.$$.dirty & /*$toast, target*/
    12) {
      $:
        $$invalidate(0, items = $toast.filter((i) => i.target === target));
    }
  };
  return [items, options, target, $toast];
}
var SvelteToast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { options: 1, target: 2 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteToast",
      options,
      id: create_fragment2.name
    });
  }
  get options() {
    throw new Error("<SvelteToast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<SvelteToast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<SvelteToast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<SvelteToast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteToast_default = SvelteToast;
export {
  SvelteToast_default as SvelteToast,
  toast
};
//# sourceMappingURL=@zerodevx_svelte-toast.js.map
